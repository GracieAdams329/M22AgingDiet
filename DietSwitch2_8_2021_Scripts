#Recall fast5 files using Dorado
SCRIPT NAME: tarunzipscript.sh
-------
#!/bin/bash
#SBATCH --mem=8G
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.tar030225_030225.out
#SBATCH --time=24:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

# Set the OPENMP_NUM_THREADS environment variable to ensure efficient core usage.
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

cd /fastdata/bop23ga/DietSwitch2_8_2021/
tar -xvzf CharlotteDGRPMarch2021-Library1-100821.tar.gz
#x - instructs tar to extract the files from the zipped file.
#v - lists out the files it's extracting.
#z - instructs tar to decompress the files.
#f - tells tar the filename.
-------
cd /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210810_1109_X1_FAP19676_a2f40c94/fast5_pass/
ls >> barclist.txt
mv barclist.txt fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass
cd fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass/Lib01
barclist=$(cat ../barclist.txt)
for {g} in ${barclist[@]}
do
mv /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210810_1109_X1_FAP19676_a2f40c94/fast5_pass/${g} .
done

for {g} in ${barclist[@]}
do
mv /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210813_1545_X1_FAP19676_53dfc8e1/fast5_pass/${g}/* ./${g}
done

SCRIPT NAME: pod5convertscript.sh
-------
#SBATCH --mem=16G
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.pod5convert_DATE0225.out
#SBATCH --time=24:00:00

#Activate the repository
barclist=$(cat ../barclist.txt)

for g in ${barclist[@]}
do
pod5 convert fast5 ${g}/*.fast5 --output ${g}.pod5
-------

SCRIPT NAME: Doradobasecallscript.sh
-------
#!/bin/bash
#SBATCH --partition=gpu
#SBATCH --qos=gpu
#SBATCH --nodes=1
#SBATCH --gpus-per-node=1
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.Doradocall_030325.out
#SBATCH --time=8:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

cd /fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass/Lib01/
barclist=$(cat ../barclist.txt)

for g in ${barclist[@]}
do
dorado basecaller hac ${g}.pod5 > /fastdata/bop23ga/DietSwitch2_8_2021/fastq_recalled/Lib01_${g}.fastq --emit-fastq
done
-------

#######USING THE PREVIOUS SAMPLES FOR THE BELOW CODE AS NEED DATA FOR POSTER!#######





#Combined the fastq files for each barcode as usual, then renamed them sample names for ease and trimmed barcodes using Dorado (see: https://github.com/GracieAdams329/ONT-RNASeq-Pipeline/blob/main/Step1-combine-trim-fastq)
#Then run:
SCRIPT NAME: MinimapStringtieSalmonScript_DS2021.sh
-------
#!/bin/bash
#SBATCH --mem=16G
#SBATCH --cpus-per-task=4
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.MinimapStringtieSalmonDS2021_210125.out
#SBATCH --time=72:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

# Set the OPENMP_NUM_THREADS environment variable to ensure efficient core usage.
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

SampleArray=$(cat /fastdata/bop23ga/DietSwitch2_8_2021/samplelist.txt)

for g in ${SampleArray[@]}
do
#Aligment to genome using minimap2
minimap2 -ax splice -p 1.0 -N 100 /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa /fastdata/bop23ga/DietSwitch2_8_2021/fastq_TOUSE/${g}_merge_trimmed.fastq | samtools view -b > /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}.bam
samtools sort -@ 2 -m 4G -o /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}_sorted.bam /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}.bam
done

for g in ${SampleArray[@]}
do
#StringTie to assemble transcripts into a transcriptome according to the gene info from the genome
#Merge with StringTie
stringtie -p 2 -B -L -e -G /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.103.gtf -o /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}/${g}_stringtie.gtf /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}_sorted.bam
done

for g in ${SampleArray[@]}
do
#Aligment to transcriptome using minimap2 for salmon
minimap2 -ax splice -p 1.0 -N 100 /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.cdna.all.fa /fastdata/bop23ga/DietSwitch2_8_2021/fastq_TOUSE/${g}_merge_trimmed.fastq | samtools view -b > /fastdata/bop23ga/DietSwitch2_8_2021/MinimapCDNAOut/${g}.bam
done

source /usr/local/community/Genomics/apps/miniconda/etc/profile.d/conda.sh
conda activate /usr/local/community/Genomics/apps/mambaforge/envs/salmon

for g in ${SampleArray[@]}
do
#Get read counts with salmon
salmon quant --ont -t /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.cdna.all.fa -l U -a /fastdata/bop23ga/DietSwitch2_8_2021/MinimapCDNAOut/${g}.bam -o /fastdata/bop23ga/DietSwitch2_8_2021/SalmonOut/${g}_salmonout/
done
-------

#The .ctab file made by StringTie to be used with the Ballgown R package use FPKM, whereas we want TPM (https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/) which is in the .gtf file.

cd /fastdata/bop23ga/DietSwitch2_8_2021/
barclist=$(cat samplelist.txt)

#Make TPMFiles folder in MinimapOut
#Note that for the below code, if copied and pasted as a block it throws an error - make sure to type/copy and paste the individual lines!
for g in ${barclist[@]}
do
cd MinimapOut/${g}
grep -P "\ttranscript\t" ${g}_stringtie.gtf | cut -f9 | grep -P "FBtr" | awk '{gsub("\"","",$0);gsub(";","",$0);print $4,$11,$12}' > ../TPMFiles/${g}_TPM.txt
cd /fastdata/bop23ga/DietSwitch2_8_2021/
done

#Make flagstats folder in MinimapOut
#In MinimapOut folder (to get counts for comparison with StringTie)
for g in ${barclist[@]}
do
samtools flagstat ${g}_sorted.bam > flagstats/${g}_sorted_flagstat.txt
done

#Make flagstats folder in MinimapCDNAOut
#In MinimapCDNAOut folder (to get counts for comparison with Salmon)
for g in ${barclist[@]}
do
samtools flagstat ${g}.bam > flagstats/${g}_flagstat.txt
done

#Copy across to shared drive:
- merge_trimmed fastqs
- MinimapOut
- MinimapCDNAOut
- SalmonOut
____________________________________________________________________________________________________________________________________________________________________________________
R SCRIPT: SalmonvsStringtieTPM.R
-------
rm(list=ls())

library(tidyverse)
library(corrplot)
library(cluster)







# ##-------Checking method works for comparing one sample
# #Read in TPM from Salmon and StringTie
# setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
# 
# salmon <- read.table('SalmonOut/Sample001_salmonout/quant.sf', header = TRUE)
# salmon <- salmon[ -c(2, 3, 5)]
# colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
# 
# stringtie <- read.table('Stringtie_e_option/TPMFiles/Sample001_TPM.txt', fill = TRUE)
# stringtie <- stringtie[ -2]
# colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
# colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
# 
# TPM <- merge(salmon, stringtie, by = "Name")
# 
# #Explore the data
# ggplot(TPM, aes(x = SalmonTPM, y = StringtieTPM)) +
#   geom_point()
# 
# TPM$Salmon_over_Stringtie = TPM$SalmonTPM/TPM$StringtieTPM
# ggplot(TPM, aes(x = Name, y = Salmon_over_Stringtie)) +
#   geom_point()
# 
# TPM$logSalmonTPM = log10(TPM$SalmonTPM)
# TPM$logStringtieTPM = log10(TPM$StringtieTPM)
# ggplot(TPM, aes(x = logSalmonTPM, y = logStringtieTPM)) +
#   geom_point()
# 
# TPM$logSalmon_over_logStringtie = TPM$logSalmonTPM/TPM$logStringtieTPM
# ggplot(TPM, aes(x = Name, y = logSalmon_over_logStringtie)) +
#   geom_point()
# 
# #Correlation plots
# chart.Correlation(TPM[,2:3], histogram=TRUE)







##-------Loop to read in all samples and make a large dataframe for correlation plots
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
samplelist <- read.table("samplelist_69.txt")
samplelist = samplelist$V1

#Make transcripts variable to store all transcripts in all samples
transcripts <- character()

for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  
  salmon <- read.table(paste('SalmonOut/', currentsample, '_salmonout/quant.sf', sep = ''), header = TRUE, fill = TRUE)
  salmon <- salmon[ -c(2, 3, 5)]
  colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
  
  stringtie <- read.table(paste('Stringtie_e_option/TPMFiles/', currentsample, '_TPM.txt', sep = ''), fill = TRUE)
  stringtie <- stringtie[ -2]
  colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
  colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
  
  TPM <- merge(salmon, stringtie, by = "Name")
  
  #Fetch the transcripts from this sample's TPM dataframe
  transcripts <- append(transcripts, TPM$Name)
}

#Fetch unique transcripts out and make dataframe for merging
overallTPM <- as.data.frame(unique(transcripts))
colnames(overallTPM)[colnames(overallTPM) == "unique(transcripts)"] <- "Name"

stdups <- character()

#Run loop to merge for all samples
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  
  salmon <- read.table(paste('SalmonOut/', currentsample, '_salmonout/quant.sf', sep = ''), header = TRUE, fill = TRUE)
  salmon <- salmon[ -c(2, 3, 5)]
  colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
  salmon <- subset(salmon, SalmonTPM > 0)
  salmon$logSalmonTPM <- log10(salmon$SalmonTPM)
  salmon <- salmon[ -2]
  
  stringtie <- read.table(paste('Stringtie_e_option/TPMFiles/', currentsample, '_TPM.txt', sep = ''), fill = TRUE)
  stringtie <- stringtie[ -2]
  colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
  colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
  stringtie <- subset(stringtie, StringtieTPM > 0)
  stringtie$logStringtieTPM <- log10(stringtie$StringtieTPM)
  stringtie <- stringtie[ -2]
  
  stdups <- append(stdups, length(which(duplicated(stringtie$Name))))
  
  #Remove lowest and highest 5% of reads
  sal_quantile <- quantile(salmon$logSalmonTPM, c(0.05, 0.95))
  sal_quantile
  salmon <- salmon[salmon$logSalmonTPM > sal_quantile[1] &
                     salmon$logSalmonTPM < sal_quantile[2], ]
  
  st_quantile <- quantile(stringtie$logStringtieTPM, c(0.05, 0.95))
  st_quantile
  stringtie <- stringtie[stringtie$logStringtieTPM > st_quantile[1] &
                           stringtie$logStringtieTPM < st_quantile[2], ]
  
  TPM <- merge(salmon, stringtie, by = "Name")
  colnames(TPM)[colnames(TPM) == "logSalmonTPM"] <- paste("logSalmonTPM_", currentsample, sep = "")
  colnames(TPM)[colnames(TPM) == "logStringtieTPM"] <- paste("logStringtieTPM_", currentsample, sep = "")
  
  overallTPM <- left_join(overallTPM, TPM, by = "Name", keep = FALSE, multiple = "first")
  #Just takes the first value for the duplicated transcripts - must be an error in StringTie but it's in so few transcripts we can ignore for now.
}

#Convert gene name to rownames
overallTPM <- column_to_rownames(overallTPM, var = "Name")

stdups
#To check how many duplications there were - should be very few.







##-------Investigating how the samples correlate
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R/')
#Ready to save plots etc.

corrtable <- cor(overallTPM, use = "complete.obs")
#This produces a similarity matrix, as the similar values are 1. A dissimilarity matrix is the opposite!

TPMagnes <- agnes(x = corrtable, diss = FALSE)
plot(TPMagnes, which.plots = 2, main = "Dendrogram of Salmon and StringTie TPM value clustering", sub = "TPMs for each transcript correlated using cor then clustered with agnes")
#This gives a dendrogram showing Salmon and StringTie seem to cluster with themselves.
#Save as png.

#To look at correlation values from cor:
ODD <- seq(from = 1, to = 138, by = 2)
EVEN <- seq(from = 2, to = 138, by = 2)

#Correlations visualised with corrplot
pdf("corrplots_Salmon_StringTie_TPM_correlations_minus5and95p.pdf", width = 33, height = 33)
corrplot(corrtable[ODD,ODD], method = "number")
corrplot(corrtable[EVEN,EVEN], method = "number")
corrplot(corrtable[ODD,EVEN], method = "number")
dev.off()

#Correlation histograms for entire similarity matrix
salmean <- round(mean(corrtable[ODD,ODD], na.rm = TRUE), digits = 3)
stmean <- round(mean(corrtable[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmean <- round(mean(corrtable[ODD,EVEN], na.rm = TRUE), digits = 3)

salmed <- round(median(corrtable[ODD,ODD], na.rm = TRUE), digits = 3)
stmed <- round(median(corrtable[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmed <- round(median(corrtable[ODD,EVEN], na.rm = TRUE), digits = 3)

pdf("histogram_Salmon_StringTie_TPM_correlations_minus5and95p.pdf", width = 10, height = 10)
hist(corrtable[ODD,ODD], main = "Histogram of correlation coefficients for Salmon vs Salmon TPMs",  sub = paste("mean =", salmean, "median =", salmed, sep = " "))
hist(corrtable[EVEN,EVEN], main = "Histogram of correlation coefficients for StringTie vs StringTie TPMs", sub = paste("mean =", stmean, "median =", stmed, sep = " "))
hist(corrtable[ODD,EVEN], main = "Histogram of correlation coefficients for Salmon vs StringTie TPMs", sub = paste("mean =", bothmean, "median =", bothmed, sep = " "))
dev.off()

#To get the off-diagonal matrix only:
offdiagcorr <- corrtable
offdiagcorr[lower.tri(offdiagcorr, diag = TRUE)] <- NA

salmean <- round(mean(offdiagcorr[ODD,ODD], na.rm = TRUE), digits = 3)
stmean <- round(mean(offdiagcorr[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmean <- round(mean(offdiagcorr[ODD,EVEN], na.rm = TRUE), digits = 3)

salmed <- round(median(offdiagcorr[ODD,ODD], na.rm = TRUE), digits = 3)
stmed <- round(median(offdiagcorr[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmed <- round(median(offdiagcorr[ODD,EVEN], na.rm = TRUE), digits = 3)

#Histogram of off-diagonal correlation coefficients (removes repeats and samples correlated to themselves)
pdf("histogram_Salmon_StringTie_TPM_correlations_uppertri_minus5and95p.pdf", width = 10, height = 10)
hist(offdiagcorr[ODD,ODD], main = "Histogram of off-diagonal correlation coefficients for Salmon vs Salmon TPMs", sub = paste("mean =", salmean, "median =", salmed, sep = " "))
hist(offdiagcorr[EVEN,EVEN], main = "Histogram of off-diagonal correlation coefficients for StringTie vs StringTie TPMs", sub = paste("mean =", stmean, "median =", stmed, sep = " "))
hist(offdiagcorr[ODD,EVEN], main = "Histogram of off-diagonal correlation coefficients for Salmon vs StringTie TPMs", sub = paste("mean =", bothmean, "median =", bothmed, sep = " "))
dev.off()







##-------Compare Salmon and StringTie counts per sample to minimap2 mapped reads
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
samplelist <- read.table("samplelist_69.txt")
samplelist = samplelist$V1

#For StringTie
allcovsums <- data.frame(Sample = character(),
                            Stringtie_count = integer())

#Loop to fetch sum(t_data.ctab$cov) (cov is per-base coverage for the transcript) for each sample
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  tdat <- read.table(paste("MinimapOut/", currentsample, "/t_data.ctab", sep = ''), header = TRUE, fill = TRUE)
  covsum <- as.data.frame(sum(tdat$cov))
  covsum$Sample = paste(currentsample)
  colnames(covsum)[colnames(covsum) == "sum(tdat$cov)"] <- "Stringtie_count"
  covsum <- covsum[,c(2,1)]
  allcovsums <- rbind(allcovsums, covsum)
}

#For Salmon
allnumsums <- data.frame(Sample = character(),
                       Salmon_count = integer())

#Loop to fetch sum(quant.sf$NumReads)
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  quant <- read.table(paste("SalmonOut/", currentsample, "_salmonout/quant.sf", sep = ''), header = TRUE, fill = TRUE)
  numsum <- as.data.frame(sum(quant$NumReads))
  numsum$Sample = paste(currentsample)
  colnames(numsum)[colnames(numsum) == "sum(quant$NumReads)"] <- "Salmon_count"
  numsum <- numsum[,c(2,1)]
  allnumsums <- rbind(allnumsums, numsum)
}

#For minimap2 (genome mapping flagstats to compare to StringTie)
allminreads_gen <- data.frame(Sample = character(),
                          minimap2_gen_count = integer())

#Loop to fetch
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  flagstatg <- readLines(paste("MinimapOut/flagstats/", currentsample, "_sorted_flagstat.txt", sep = ''))
  sec <- as.integer(flagstatg[2] %>% str_sub(1,7))
  supp <- as.integer(flagstatg[3] %>% str_sub(1,5))
  secsupp <- (sec + supp)
  all <- as.integer((flagstatg[5] %>% str_sub(1,7)))
  minreadsg <- as.data.frame(all - secsupp)
  minreadsg$Sample = paste(currentsample)
  colnames(minreadsg)[1] <- "minimap2_gen_count" #Have to do by column number as won't match names for some reason
  minreadsg <- minreadsg[,c(2,1)]
  allminreads_gen <- rbind(allminreads_gen, minreadsg)
}
#NA for sample 55 due to low read number so manually add the calcs for that one:
currentsample = samplelist[19]
flagstatg <- readLines(paste("MinimapOut/flagstats/", currentsample, "_sorted_flagstat.txt", sep = ''))
sec <- as.integer(flagstatg[2] %>% str_sub(1,5))
supp <- as.integer(flagstatg[3] %>% str_sub(1,4))
secsupp <- (sec + supp)
all <- as.integer((flagstatg[5] %>% str_sub(1,6)))
minreadsg <- as.data.frame(all - secsupp)
minreadsg$Sample = paste(currentsample)
colnames(minreadsg)[1] <- "minimap2_gen_count" #Have to do by column number as won't match names for some reason
minreadsg <- minreadsg[,c(2,1)]
allminreads_gen <- rbind(allminreads_gen, minreadsg)
#Remove the original Sample055 from row 19
allminreads_gen <- allminreads_gen[-c(19),]

#For minimap2 (transcriptome mapping flagstats to compare to Salmon)
allminreads_tran <- data.frame(Sample = character(),
                              minimap2_tran_count = integer())

#Loop to fetch
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  flagstatt <- readLines(paste("MinimapCDNAOut/flagstats/", currentsample, "_flagstat.txt", sep = ''))
  sec <- as.integer(flagstatt[2] %>% str_sub(1,7))
  supp <- as.integer(flagstatt[3] %>% str_sub(1,5))
  secsupp <- (sec + supp)
  all <- as.integer((flagstatt[5] %>% str_sub(1,7)))
  minreadst <- as.data.frame(all - secsupp)
  minreadst$Sample = paste(currentsample)
  colnames(minreadst)[1] <- "minimap2_tran_count" #Have to do by column number as won't match names for some reason
  minreadst <- minreadst[,c(2,1)]
  allminreads_tran <- rbind(allminreads_tran, minreadst)
}

allcounts <- merge(allcovsums, allnumsums, by = "Sample")
allcounts <- merge(allcounts, allminreads_gen, by = "Sample")
allcounts <- merge(allcounts, allminreads_tran, by = "Sample")


#Plot
allcounts$Stringtieoverminimap2 = (allcounts$Stringtie_count/allcounts$minimap2_gen_count)
allcounts$Salmonoverminimap2 = (allcounts$Salmon_count/allcounts$minimap2_tran_count)

colours <- c("Stringtieoverminimap2" = "black", "Salmonoverminimap2" = "red")

ggplot(allcounts, aes(x = Sample)) +
  geom_point(data = allcounts, aes(x = Sample, y = Stringtieoverminimap2, colour = "Stringtieoverminimap2")) +
  geom_point(data = allcounts, aes(x = Sample, y = Salmonoverminimap2, colour = "Salmonoverminimap2")) +
  theme_bw() +
  scale_colour_manual(name = NULL, values = colours) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(y = "counts") +
  geom_hline(yintercept = 1, linetype = "dashed") +
  ylim(0, 1)

allcounts$RatioDiffString = ((allcounts$minimap2_gen_count-allcounts$Stringtie_count)/allcounts$minimap2_gen_count)
allcounts$RatioDiffSal = ((allcounts$minimap2_tran_count-allcounts$Salmon_count)/allcounts$minimap2_tran_count)

colours <- c("RatioDiffString" = "black", "RatioDiffSal" = "red")

ggplot(allcounts, aes(x = Sample)) +
  geom_point(data = allcounts, aes(x = Sample, y = RatioDiffString, colour = "RatioDiffString")) +
  geom_point(data = allcounts, aes(x = Sample, y = RatioDiffSal, colour = "RatioDiffSal")) +
  theme_bw() +
  scale_colour_manual(name = NULL, values = colours) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(y = "minimap2 counts minus StringTie or Salmon counts\ndivided by minimap2 counts") +
  ylim(0, 1)
____________________________________________________________________________________________________________________________________________________________________________________
#R SCRIPT: SalmonDownstream_DTU_DS21.R
-------
#https://www.bioconductor.org/packages/release/workflows/vignettes/rnaseqDTU/inst/doc/rnaseqDTU.html
#https://bioconductor.org/packages/release/bioc/vignettes/DRIMSeq/inst/doc/DRIMSeq.pdf
#See also the QTL analysis workflow in DRIMSeq vignette
#install.packages("BiocManager")
#BiocManager::install(version = "3.20")
#library(BiocManager)
#BiocManager::install("DRIMSeq")
#BiocManager::install("DEXSeq")
#BiocManager::install("stageR")
#BiocManager::install("tximport")
#BiocManager::install("txdbmaker")

rm(list=ls())

library(DRIMSeq)
library(DEXSeq)
library(stageR)
library(tximport)
library(txdbmaker)
library(GenomicFeatures)
library(dplyr)

#Importing counts
setwd("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R")
ALLsamps <- read.csv("DS2_8_2021_samples.csv")
#Run analysis for each line individually to loop through - currently don't know how to use ~diet+line model so do separately for now
lines <- unique(ALLsamps$line)
#Set up overall DF to store results
overall_drim.padj <- setNames(data.frame(matrix(ncol = 5, nrow = 0)), c("line", "geneID", "txID", "gene", "transcript"))

for(i in 1:length(lines))
{
  #i = 2
  samps <- filter(ALLsamps, line == lines[i])
  files <- file.path("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/SalmonOut/",samps$sample_id,"_salmonout/quant.sf", fsep = "")
  names(files) <- samps$sample_id
  files
  
  txi <- tximport(files, type = "salmon", txOut = TRUE,
                  countsFromAbundance = "scaledTPM")
  cts <- txi$counts
  cts <- cts[rowSums(cts) > 0,]
  
  #Transcript-to-gene mapping
  #Need .gtf file from ensembl: https://ftp.ensembl.org/pub/release-109/gtf/drosophila_melanogaster/
  gtf <- "Z:/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.109.gtf"
  txdb.filename <- "Z:/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.109.sqlite"
  txdb <- makeTxDbFromGFF(gtf)
  #saveDb(txdb, txdb.filename)
  #Once made this can be quickly reloaded (not totally sure what the benefit of this is yet? Maybe save externally to R?):
  #txdb <- loadDb(txdb.filename)
  txdf <- AnnotationDbi::select(txdb, keys(txdb, "GENEID"), "TXNAME", "GENEID") #use select from AnnotationDbi NOT dplyr!
  tab <- table(txdf$GENEID)
  txdf$ntx <- tab[match(txdf$GENEID, names(tab))]
  
  
  
  ##-------Statistical analysis of differential transcript usage
  ##-------DRIMSeq
  #Can also account for batch effects in DRIMSeq if needed - THIS MAY BE AN OPTION FOR THE LINES??
  #Data frame
  counts <- data.frame(gene_id = txdf$GENEID, feature_id = txdf$TXNAME)
  cts <- as.data.frame(cts)
  cts <- tibble::rownames_to_column(cts, "feature_id")
  counts <- merge(counts, cts, by = "feature_id")
  
  #DRIMSeq
  d <- dmDSdata(counts = counts, samples = samps)
  d
  #Filtering
  n = nrow(samps) #no. samples
  if (n < 6) {n.small <- 2} else if (n == 6) {n.small <- 3} #sample size of smallest group - accounts for some samples being omitted
  #For a transcript to be retained, we require that:
  d <- dmFilter(d,
                min_samps_feature_expr = n.small, min_feature_expr = 1, #it has a count of at least X in at least n.small samples
                min_samps_feature_prop = n.small, min_feature_prop = 0.01, #it has a relative abundance proportion of at least X in at least n.small samples
                min_samps_gene_expr = n, min_gene_expr = 1) #the total count of corresponding gene is at least X in all n samples
  d
  #The two count filters are the only ones used in the original DRIMSeq vignette
  #Only genes that have >1 isoform since we are looking at DTU
  #To see how many of the remaining genes have N isoforms:
  table(table(counts(d)$gene_id))
  
  #Precision, proportion and DTU estimation
  #Design matrix
  #Check csv is ordered so 'Rich_Control' samples are above 'DR_Switch' for levelling purposes!
  design_full <- model.matrix(~ diet, data = DRIMSeq::samples(d))
  colnames(design_full)
  
  #Following 3 functions estimate model parameters and test for DTU
  set.seed(1)
  system.time({
    d <- dmPrecision(d, design = design_full) #estimate the precision, which is related to the dispersion in the Dirichlet Multinomial model
    d <- dmFit(d, design = design_full) #fit regression coefficients and perform null hypothesis testing on the coefficient of interest
    d <- dmTest(d, coef = "dietDR_Switch") #coef parameter indicates which columns of full design should be removed to get null design (eg. the treatment)
  })
  
  pdf(paste(lines[i], "_DRIMSeq_Precision_Proportion_DTUest.pdf"), width = 10, height = 10)
  print(plotPrecision(d))
  #head(coefficients(d))
  #head(DRIMSeq::results(d))
  print(plotPValues(d))
  print(plotPValues(d, level= "feature"))
  dev.off()
  
  #Save results tables, also as objects for later
  res <- DRIMSeq::results(d)
  res.txp <- DRIMSeq::results(d, level="feature")
  assign(paste(lines[i], "res", sep = "_"), DRIMSeq::results(d))
  assign(paste(lines[i], "res.txp", sep = "_"), DRIMSeq::results(d, level="feature"))
  
  #Plot estimated proportions for one of the significant genes where evidence of isoform switching
  #FOCUS ON stageR RESULTS FOR NOW!
  #idx <- which(res$adj_pvalue < 0.05)[1]
  #res[idx,]
  #plotProportions(d, gene_id = res$gene_id[idx], group_variable = "diet", plot_type = "lineplot")
  
  #Turn p value NAs into 1s as they would cause issues for stage-wise analysis
  no.na <- function(x) ifelse(is.na(x), 1, x)
  res$pvalue <- no.na(res$pvalue)
  res.txp$pvalue <- no.na(res.txp$pvalue)
  
  
  
  ##-------stageR
  #stageR asks 1. which genes contain evidence of DTU? 2. which transcripts in those genes are participating in the DTU?
  #Two steps: screening and confirmation
  #Assign gene-level pvalues to the screening stage
  pScreen <- res$pvalue
  names(pScreen) <- res$gene_id
  #Assign tx-level pvalues to the confirmation stage
  pConfirmation <- matrix(res.txp$pvalue, ncol = 1)
  rownames(pConfirmation) <- res.txp$feature_id
  #Create gene-tx mapping
  tx2gene <- res.txp[, c("feature_id", "gene_id")]
  #Create the stageRTx object and perform stage-wise analysis
  stageR0bj <- stageRTx(pScreen = pScreen, pConfirmation = pConfirmation, pScreenAdjusted = FALSE, tx2gene = tx2gene)
  stageR0bj <- stageWiseAdjustment(object = stageR0bj, method = "dtu", alpha = 0.1)
  getSignificantGenes(stageR0bj)
  getSignificantTx(stageR0bj)
  drim.padj <- getAdjustedPValues(stageR0bj, order = TRUE, onlySignificantGenes = FALSE)
  head(drim.padj)
  #The final table with adjusted p-values summarizes the information from the two-stage analysis
  #Only genes that passed the filter are included in the table, so the table already represents screened genes
  #The transcripts with values in the column, transcript, less than 0.05 pass the confirmation stage on a target
  #5% overall false discovery rate, or OFDR. This means that, in expectation, no more than 5% of the genes that
  #pass screening will either (1) not contain any DTU, so be falsely screened genes, or (2) contain a falsely confirmed
  #transcript. A falsely confirmed transcript is a transcript with an adjusted p-value less than 0.05 which does not
  #exhibit differential usage across condition. The stageR procedure allows us to look at both the genes that passed the
  #screening stage and the transcripts with adjusted p-values less than our target alpha, and understand what kind of
  #overall error rate this procedure entails. This cannot be said for an arbitrary procedure of looking at standard gene
  #adjusted p-values and transcript adjusted p-values, where the adjustment was performed independently.
  drim.padj$line = paste(lines[i])
  drim.padj <- drim.padj[,c(5, 1, 2, 3, 4)]
  overall_drim.padj <- rbind(overall_drim.padj, drim.padj)
}  
  
  
 
  
  
  
   
#BELOW NOT RUN FOR POSTER DATA
  
##-------Post-hoc filtering on the standard deviation in proportions
#DRIMSeq can exceed FDR bounds so post-hoc filtering of p vals improved FDR/OFDR control. Use SD for filtering
#P vals may no longer be uniform after filtering out small effect txs and genes, but probably makes it MORE conservative
res.txp.filt <- DRIMSeq::results(d, level = "feature")
smallProportionSD <- function(d, filter = 0.1) {
  cts <- as.matrix(subset(counts(d), select = -c(gene_id, feature_id)))
  gene.cts <- rowsum(cts, counts(d)$gene_id)
  total.cts <- gene.cts[match(counts(d)$gene_id, rownames(gene.cts)),]
  props <- cts/total.cts
  propSD <- sqrt(rowVars(props))
  propSD < filter
}
filt <- smallProportionSD(d)
res.txp.filt$pvalue[filt] <- 1 
res.txp.filt$adj_pvalue[filt] <- 1



##-------DEXSeq
#When it says 'exon', this means 'transcript' for our analysis
#DEXSeq will test – after accounting for total gene expression for this sample and for the proportion of this transcript
#relative to the others – whether there is a condition-specific difference in the transcript proportion relative to others
sample.data <- DRIMSeq::samples(d)
count.data <- round(as.matrix(counts(d)[,-c(1:2)]))
dxd <- DEXSeqDataSet(countData = count.data,
                     sampleData = sample.data,
                     design = ~sample + exon + diet:exon,
                     featureID = counts(d)$feature_id,
                     groupID = counts(d)$gene_id)
#DEXSeq analysis
system.time({
  dxd <- estimateSizeFactors(dxd)
  dxd <- estimateDispersions(dxd, quiet = TRUE)
  dxd <- testForDEU(dxd, reducedModel = ~sample + exon)
})
#Compute per-gene adjusted p val and construct results table
dxr <- DEXSeqResults(dxd, independentFiltering = FALSE)
qval <- perGeneQValue(dxr)
dxr.g <- data.frame(gene = names(qval), qval)
#Can also reduce tx-level results table to simple df
columns <- c("featureID", "groupID", "pvalue")
dxr <- as.data.frame(dxr[,columns])
head(dxr)



##-------stageR following DEXSeq
#Similar code to that used for stageR above
strp <- function(x) substr(x, 1, 15)
pConfirmation <- matrix(dxr$pvalue, ncol= 1)
dimnames(pConfirmation) <- list(strp(dxr$featureID), "transcript")
pScreen <- qval
names(pScreen) <- strp(names(pScreen))
tx2gene <- as.data.frame(dxr[,c("featureID", "groupID")])
for (i in 1:2) tx2gene[,i] <- strp(tx2gene[,i])
#Following three functions provide a table with the OFDR control described above
#Set of genes passing screening should not have more than (alpa)% of either genes which have in fact no DTU or genes
#which contain a transcript with an adjusted p-value less than (alpha)% which do not participate in DTU
stageRObj <- stageRTx(pScreen = pScreen, pConfirmation = pConfirmation,
                      pScreenAdjusted = TRUE, tx2gene = tx2gene)
stageRObj <- stageWiseAdjustment(stageRObj, method = "dtu", alpha = 0.1)
suppressWarnings({
  dex.padj <- getAdjustedPValues(stageRObj, order = FALSE,
                                 onlySignificantGenes = TRUE)
})
head(dex.padj)

#Stopped at section 6 as don't need DGE right now
