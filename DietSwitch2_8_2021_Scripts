#Recall fast5 files using Dorado
SCRIPT NAME: tarunzipscript.sh
-------
#!/bin/bash
#SBATCH --mem=8G
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.tar030225_030225.out
#SBATCH --time=24:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

# Set the OPENMP_NUM_THREADS environment variable to ensure efficient core usage.
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

cd /fastdata/bop23ga/DietSwitch2_8_2021/
tar -xvzf CharlotteDGRPMarch2021-Library1-100821.tar.gz
#x - instructs tar to extract the files from the zipped file.
#v - lists out the files it's extracting.
#z - instructs tar to decompress the files.
#f - tells tar the filename.
-------
cd /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210810_1109_X1_FAP19676_a2f40c94/fast5_pass/
ls >> barclist.txt
mv barclist.txt fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass
cd fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass/Lib01
barclist=$(cat ../barclist.txt)
for {g} in ${barclist[@]}
do
mv /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210810_1109_X1_FAP19676_a2f40c94/fast5_pass/${g} .
done

for {g} in ${barclist[@]}
do
mv /fastdata/bop23ga/DietSwitch2_8_2021/CharlotteDGRPMarch2021-Library1-100821/no_sample/20210813_1545_X1_FAP19676_53dfc8e1/fast5_pass/${g}/* ./${g}
done

SCRIPT NAME: pod5convertscript.sh
-------
#SBATCH --mem=16G
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.pod5convert_DATE0225.out
#SBATCH --time=24:00:00

#Activate the repository
barclist=$(cat ../barclist.txt)

for g in ${barclist[@]}
do
pod5 convert fast5 ${g}/*.fast5 --output ${g}.pod5
-------

SCRIPT NAME: Doradobasecallscript.sh
-------
#!/bin/bash
#SBATCH --partition=gpu
#SBATCH --qos=gpu
#SBATCH --nodes=1
#SBATCH --gpus-per-node=1
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.Doradocall_030325.out
#SBATCH --time=8:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

cd /fastdata/bop23ga/DietSwitch2_8_2021/fast5_pass/Lib01/
barclist=$(cat ../barclist.txt)

for g in ${barclist[@]}
do
dorado basecaller hac ${g}.pod5 > /fastdata/bop23ga/DietSwitch2_8_2021/fastq_recalled/Lib01_${g}.fastq --emit-fastq
done
-------

#######USING THE PREVIOUS SAMPLES FOR THE BELOW CODE AS NEED DATA FOR POSTER!#######





#Combined the fastq files for each barcode as usual, then renamed them sample names for ease and trimmed barcodes using Dorado (see: https://github.com/GracieAdams329/ONT-RNASeq-Pipeline/blob/main/Step1-combine-trim-fastq)
#Then run:
SCRIPT NAME: MinimapStringtieSalmonScript_DS2021.sh
-------
#!/bin/bash
#SBATCH --mem=16G
#SBATCH --cpus-per-task=4
#SBATCH --mail-user=gadams3@sheffield.ac.uk
#SBATCH --mail-type=ALL
#SBATCH --output=output.MinimapStringtieSalmonDS2021_210125.out
#SBATCH --time=72:00:00

#Activate the repository
#echo -e "if [[ -e '/usr/local/extras/Genomics' ]];\nthen\n\tsource /usr/local/extras/Genomics/.bashrc\nfi" >> $HOME/.bash_profile
source /usr/local/extras/Genomics/.bashrc

# Set the OPENMP_NUM_THREADS environment variable to ensure efficient core usage.
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

SampleArray=$(cat /fastdata/bop23ga/DietSwitch2_8_2021/samplelist.txt)

for g in ${SampleArray[@]}
do
#Aligment to genome using minimap2
minimap2 -ax splice -p 1.0 -N 100 /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.dna.toplevel.fa /fastdata/bop23ga/DietSwitch2_8_2021/fastq_TOUSE/${g}_merge_trimmed.fastq | samtools view -b > /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}.bam
samtools sort -@ 2 -m 4G -o /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}_sorted.bam /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}.bam
done

for g in ${SampleArray[@]}
do
#StringTie to assemble transcripts into a transcriptome according to the gene info from the genome
#Merge with StringTie
stringtie -p 2 -B -L -e -G /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.103.gtf -o /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}/${g}_stringtie.gtf /fastdata/bop23ga/DietSwitch2_8_2021/MinimapOut/${g}_sorted.bam
done

for g in ${SampleArray[@]}
do
#Aligment to transcriptome using minimap2 for salmon
minimap2 -ax splice -p 1.0 -N 100 /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.cdna.all.fa /fastdata/bop23ga/DietSwitch2_8_2021/fastq_TOUSE/${g}_merge_trimmed.fastq | samtools view -b > /fastdata/bop23ga/DietSwitch2_8_2021/MinimapCDNAOut/${g}.bam
done

source /usr/local/community/Genomics/apps/miniconda/etc/profile.d/conda.sh
conda activate /usr/local/community/Genomics/apps/mambaforge/envs/salmon

for g in ${SampleArray[@]}
do
#Get read counts with salmon
salmon quant --ont -t /shared/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.cdna.all.fa -l U -a /fastdata/bop23ga/DietSwitch2_8_2021/MinimapCDNAOut/${g}.bam -o /fastdata/bop23ga/DietSwitch2_8_2021/SalmonOut/${g}_salmonout/
done
-------

#The .ctab file made by StringTie to be used with the Ballgown R package use FPKM, whereas we want TPM (https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/) which is in the .gtf file.

cd /fastdata/bop23ga/DietSwitch2_8_2021/
barclist=$(cat samplelist.txt)

#Make TPMFiles folder in MinimapOut
#Note that for the below code, if copied and pasted as a block it throws an error - make sure to type/copy and paste the individual lines!
for g in ${barclist[@]}
do
cd MinimapOut/${g}
grep -P "\ttranscript\t" ${g}_stringtie.gtf | cut -f9 | grep -P "FBtr" | awk '{gsub("\"","",$0);gsub(";","",$0);print $4,$11,$12}' > ../TPMFiles/${g}_TPM.txt
cd /fastdata/bop23ga/DietSwitch2_8_2021/
done

#Make flagstats folder in MinimapOut
#In MinimapOut folder (to get counts for comparison with StringTie)
for g in ${barclist[@]}
do
samtools flagstat ${g}_sorted.bam > flagstats/${g}_sorted_flagstat.txt
done

#Make flagstats folder in MinimapCDNAOut
#In MinimapCDNAOut folder (to get counts for comparison with Salmon)
for g in ${barclist[@]}
do
samtools flagstat ${g}.bam > flagstats/${g}_flagstat.txt
done

#Copy across to shared drive:
- merge_trimmed fastqs
- MinimapOut
- MinimapCDNAOut
- SalmonOut
____________________________________________________________________________________________________________________________________________________________________________________
R SCRIPT: SalmonvsStringtieTPM.R
-------
rm(list=ls())

library(tidyverse)
library(corrplot)
library(cluster)







# ##-------Checking method works for comparing one sample
# #Read in TPM from Salmon and StringTie
# setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
# 
# salmon <- read.table('SalmonOut/Sample001_salmonout/quant.sf', header = TRUE)
# salmon <- salmon[ -c(2, 3, 5)]
# colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
# 
# stringtie <- read.table('Stringtie_e_option/TPMFiles/Sample001_TPM.txt', fill = TRUE)
# stringtie <- stringtie[ -2]
# colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
# colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
# 
# TPM <- merge(salmon, stringtie, by = "Name")
# 
# #Explore the data
# ggplot(TPM, aes(x = SalmonTPM, y = StringtieTPM)) +
#   geom_point()
# 
# TPM$Salmon_over_Stringtie = TPM$SalmonTPM/TPM$StringtieTPM
# ggplot(TPM, aes(x = Name, y = Salmon_over_Stringtie)) +
#   geom_point()
# 
# TPM$logSalmonTPM = log10(TPM$SalmonTPM)
# TPM$logStringtieTPM = log10(TPM$StringtieTPM)
# ggplot(TPM, aes(x = logSalmonTPM, y = logStringtieTPM)) +
#   geom_point()
# 
# TPM$logSalmon_over_logStringtie = TPM$logSalmonTPM/TPM$logStringtieTPM
# ggplot(TPM, aes(x = Name, y = logSalmon_over_logStringtie)) +
#   geom_point()
# 
# #Correlation plots
# chart.Correlation(TPM[,2:3], histogram=TRUE)







##-------Loop to read in all samples and make a large dataframe for correlation plots
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
samplelist <- read.table("samplelist_69.txt")
samplelist = samplelist$V1

#Make transcripts variable to store all transcripts in all samples
transcripts <- character()

for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  
  salmon <- read.table(paste('SalmonOut/', currentsample, '_salmonout/quant.sf', sep = ''), header = TRUE, fill = TRUE)
  salmon <- salmon[ -c(2, 3, 5)]
  colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
  
  stringtie <- read.table(paste('Stringtie_e_option/TPMFiles/', currentsample, '_TPM.txt', sep = ''), fill = TRUE)
  stringtie <- stringtie[ -2]
  colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
  colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
  
  TPM <- merge(salmon, stringtie, by = "Name")
  
  #Fetch the transcripts from this sample's TPM dataframe
  transcripts <- append(transcripts, TPM$Name)
}

#Fetch unique transcripts out and make dataframe for merging
overallTPM <- as.data.frame(unique(transcripts))
colnames(overallTPM)[colnames(overallTPM) == "unique(transcripts)"] <- "Name"

stdups <- character()

#Run loop to merge for all samples
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  
  salmon <- read.table(paste('SalmonOut/', currentsample, '_salmonout/quant.sf', sep = ''), header = TRUE, fill = TRUE)
  salmon <- salmon[ -c(2, 3, 5)]
  colnames(salmon)[colnames(salmon) == "TPM"] <- "SalmonTPM"
  salmon <- subset(salmon, SalmonTPM > 0)
  salmon$logSalmonTPM <- log10(salmon$SalmonTPM)
  salmon <- salmon[ -2]
  
  stringtie <- read.table(paste('Stringtie_e_option/TPMFiles/', currentsample, '_TPM.txt', sep = ''), fill = TRUE)
  stringtie <- stringtie[ -2]
  colnames(stringtie)[colnames(stringtie) == "V1"] <- "Name"
  colnames(stringtie)[colnames(stringtie) == "V3"] <- "StringtieTPM"
  stringtie <- subset(stringtie, StringtieTPM > 0)
  stringtie$logStringtieTPM <- log10(stringtie$StringtieTPM)
  stringtie <- stringtie[ -2]
  
  stdups <- append(stdups, length(which(duplicated(stringtie$Name))))
  
  #Remove lowest and highest 5% of reads
  sal_quantile <- quantile(salmon$logSalmonTPM, c(0.05, 0.95))
  sal_quantile
  salmon <- salmon[salmon$logSalmonTPM > sal_quantile[1] &
                     salmon$logSalmonTPM < sal_quantile[2], ]
  
  st_quantile <- quantile(stringtie$logStringtieTPM, c(0.05, 0.95))
  st_quantile
  stringtie <- stringtie[stringtie$logStringtieTPM > st_quantile[1] &
                           stringtie$logStringtieTPM < st_quantile[2], ]
  
  TPM <- merge(salmon, stringtie, by = "Name")
  colnames(TPM)[colnames(TPM) == "logSalmonTPM"] <- paste("logSalmonTPM_", currentsample, sep = "")
  colnames(TPM)[colnames(TPM) == "logStringtieTPM"] <- paste("logStringtieTPM_", currentsample, sep = "")
  
  overallTPM <- left_join(overallTPM, TPM, by = "Name", keep = FALSE, multiple = "first")
  #Just takes the first value for the duplicated transcripts - must be an error in StringTie but it's in so few transcripts we can ignore for now.
}

#Convert gene name to rownames
overallTPM <- column_to_rownames(overallTPM, var = "Name")

stdups
#To check how many duplications there were - should be very few.







##-------Investigating how the samples correlate
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R/')
#Ready to save plots etc.

corrtable <- cor(overallTPM, use = "complete.obs")
#This produces a similarity matrix, as the similar values are 1. A dissimilarity matrix is the opposite!

TPMagnes <- agnes(x = corrtable, diss = FALSE)
plot(TPMagnes, which.plots = 2, main = "Dendrogram of Salmon and StringTie TPM value clustering", sub = "TPMs for each transcript correlated using cor then clustered with agnes")
#This gives a dendrogram showing Salmon and StringTie seem to cluster with themselves.
#Save as png.

#To look at correlation values from cor:
ODD <- seq(from = 1, to = 138, by = 2)
EVEN <- seq(from = 2, to = 138, by = 2)

#Correlations visualised with corrplot
pdf("corrplots_Salmon_StringTie_TPM_correlations_minus5and95p.pdf", width = 33, height = 33)
corrplot(corrtable[ODD,ODD], method = "number")
corrplot(corrtable[EVEN,EVEN], method = "number")
corrplot(corrtable[ODD,EVEN], method = "number")
dev.off()

#Correlation histograms for entire similarity matrix
salmean <- round(mean(corrtable[ODD,ODD], na.rm = TRUE), digits = 3)
stmean <- round(mean(corrtable[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmean <- round(mean(corrtable[ODD,EVEN], na.rm = TRUE), digits = 3)

salmed <- round(median(corrtable[ODD,ODD], na.rm = TRUE), digits = 3)
stmed <- round(median(corrtable[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmed <- round(median(corrtable[ODD,EVEN], na.rm = TRUE), digits = 3)

pdf("histogram_Salmon_StringTie_TPM_correlations_minus5and95p.pdf", width = 10, height = 10)
hist(corrtable[ODD,ODD], main = "Histogram of correlation coefficients for Salmon vs Salmon TPMs",  sub = paste("mean =", salmean, "median =", salmed, sep = " "))
hist(corrtable[EVEN,EVEN], main = "Histogram of correlation coefficients for StringTie vs StringTie TPMs", sub = paste("mean =", stmean, "median =", stmed, sep = " "))
hist(corrtable[ODD,EVEN], main = "Histogram of correlation coefficients for Salmon vs StringTie TPMs", sub = paste("mean =", bothmean, "median =", bothmed, sep = " "))
dev.off()

#To get the off-diagonal matrix only:
offdiagcorr <- corrtable
offdiagcorr[lower.tri(offdiagcorr, diag = TRUE)] <- NA

salmean <- round(mean(offdiagcorr[ODD,ODD], na.rm = TRUE), digits = 3)
stmean <- round(mean(offdiagcorr[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmean <- round(mean(offdiagcorr[ODD,EVEN], na.rm = TRUE), digits = 3)

salmed <- round(median(offdiagcorr[ODD,ODD], na.rm = TRUE), digits = 3)
stmed <- round(median(offdiagcorr[EVEN,EVEN], na.rm = TRUE), digits = 3)
bothmed <- round(median(offdiagcorr[ODD,EVEN], na.rm = TRUE), digits = 3)

#Histogram of off-diagonal correlation coefficients (removes repeats and samples correlated to themselves)
pdf("histogram_Salmon_StringTie_TPM_correlations_uppertri_minus5and95p.pdf", width = 10, height = 10)
hist(offdiagcorr[ODD,ODD], main = "Histogram of off-diagonal correlation coefficients for Salmon vs Salmon TPMs", sub = paste("mean =", salmean, "median =", salmed, sep = " "))
hist(offdiagcorr[EVEN,EVEN], main = "Histogram of off-diagonal correlation coefficients for StringTie vs StringTie TPMs", sub = paste("mean =", stmean, "median =", stmed, sep = " "))
hist(offdiagcorr[ODD,EVEN], main = "Histogram of off-diagonal correlation coefficients for Salmon vs StringTie TPMs", sub = paste("mean =", bothmean, "median =", bothmed, sep = " "))
dev.off()







##-------Compare Salmon and StringTie counts per sample to minimap2 mapped reads
setwd('Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/')
samplelist <- read.table("samplelist_69.txt")
samplelist = samplelist$V1

#For StringTie
allcovsums <- data.frame(Sample = character(),
                            Stringtie_count = integer())

#Loop to fetch sum(t_data.ctab$cov) (cov is per-base coverage for the transcript) for each sample
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  tdat <- read.table(paste("MinimapOut/", currentsample, "/t_data.ctab", sep = ''), header = TRUE, fill = TRUE)
  covsum <- as.data.frame(sum(tdat$cov))
  covsum$Sample = paste(currentsample)
  colnames(covsum)[colnames(covsum) == "sum(tdat$cov)"] <- "Stringtie_count"
  covsum <- covsum[,c(2,1)]
  allcovsums <- rbind(allcovsums, covsum)
}

#For Salmon
allnumsums <- data.frame(Sample = character(),
                       Salmon_count = integer())

#Loop to fetch sum(quant.sf$NumReads)
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  quant <- read.table(paste("SalmonOut/", currentsample, "_salmonout/quant.sf", sep = ''), header = TRUE, fill = TRUE)
  numsum <- as.data.frame(sum(quant$NumReads))
  numsum$Sample = paste(currentsample)
  colnames(numsum)[colnames(numsum) == "sum(quant$NumReads)"] <- "Salmon_count"
  numsum <- numsum[,c(2,1)]
  allnumsums <- rbind(allnumsums, numsum)
}

#For minimap2 (genome mapping flagstats to compare to StringTie)
allminreads_gen <- data.frame(Sample = character(),
                          minimap2_gen_count = integer())

#Loop to fetch
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  flagstatg <- readLines(paste("MinimapOut/flagstats/", currentsample, "_sorted_flagstat.txt", sep = ''))
  sec <- as.integer(flagstatg[2] %>% str_sub(1,7))
  supp <- as.integer(flagstatg[3] %>% str_sub(1,5))
  secsupp <- (sec + supp)
  all <- as.integer((flagstatg[5] %>% str_sub(1,7)))
  minreadsg <- as.data.frame(all - secsupp)
  minreadsg$Sample = paste(currentsample)
  colnames(minreadsg)[1] <- "minimap2_gen_count" #Have to do by column number as won't match names for some reason
  minreadsg <- minreadsg[,c(2,1)]
  allminreads_gen <- rbind(allminreads_gen, minreadsg)
}
#NA for sample 55 due to low read number so manually add the calcs for that one:
currentsample = samplelist[19]
flagstatg <- readLines(paste("MinimapOut/flagstats/", currentsample, "_sorted_flagstat.txt", sep = ''))
sec <- as.integer(flagstatg[2] %>% str_sub(1,5))
supp <- as.integer(flagstatg[3] %>% str_sub(1,4))
secsupp <- (sec + supp)
all <- as.integer((flagstatg[5] %>% str_sub(1,6)))
minreadsg <- as.data.frame(all - secsupp)
minreadsg$Sample = paste(currentsample)
colnames(minreadsg)[1] <- "minimap2_gen_count" #Have to do by column number as won't match names for some reason
minreadsg <- minreadsg[,c(2,1)]
allminreads_gen <- rbind(allminreads_gen, minreadsg)
#Remove the original Sample055 from row 19
allminreads_gen <- allminreads_gen[-c(19),]

#For minimap2 (transcriptome mapping flagstats to compare to Salmon)
allminreads_tran <- data.frame(Sample = character(),
                              minimap2_tran_count = integer())

#Loop to fetch
for(i in 1:length(samplelist))
{
  currentsample = samplelist[i]
  flagstatt <- readLines(paste("MinimapCDNAOut/flagstats/", currentsample, "_flagstat.txt", sep = ''))
  sec <- as.integer(flagstatt[2] %>% str_sub(1,7))
  supp <- as.integer(flagstatt[3] %>% str_sub(1,5))
  secsupp <- (sec + supp)
  all <- as.integer((flagstatt[5] %>% str_sub(1,7)))
  minreadst <- as.data.frame(all - secsupp)
  minreadst$Sample = paste(currentsample)
  colnames(minreadst)[1] <- "minimap2_tran_count" #Have to do by column number as won't match names for some reason
  minreadst <- minreadst[,c(2,1)]
  allminreads_tran <- rbind(allminreads_tran, minreadst)
}

allcounts <- merge(allcovsums, allnumsums, by = "Sample")
allcounts <- merge(allcounts, allminreads_gen, by = "Sample")
allcounts <- merge(allcounts, allminreads_tran, by = "Sample")


#Plot
allcounts$Stringtieoverminimap2 = (allcounts$Stringtie_count/allcounts$minimap2_gen_count)
allcounts$Salmonoverminimap2 = (allcounts$Salmon_count/allcounts$minimap2_tran_count)

colours <- c("Stringtieoverminimap2" = "black", "Salmonoverminimap2" = "red")

ggplot(allcounts, aes(x = Sample)) +
  geom_point(data = allcounts, aes(x = Sample, y = Stringtieoverminimap2, colour = "Stringtieoverminimap2")) +
  geom_point(data = allcounts, aes(x = Sample, y = Salmonoverminimap2, colour = "Salmonoverminimap2")) +
  theme_bw() +
  scale_colour_manual(name = NULL, values = colours) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(y = "counts") +
  geom_hline(yintercept = 1, linetype = "dashed") +
  ylim(0, 1)

allcounts$RatioDiffString = ((allcounts$minimap2_gen_count-allcounts$Stringtie_count)/allcounts$minimap2_gen_count)
allcounts$RatioDiffSal = ((allcounts$minimap2_tran_count-allcounts$Salmon_count)/allcounts$minimap2_tran_count)

colours <- c("RatioDiffString" = "black", "RatioDiffSal" = "red")

ggplot(allcounts, aes(x = Sample)) +
  geom_point(data = allcounts, aes(x = Sample, y = RatioDiffString, colour = "RatioDiffString")) +
  geom_point(data = allcounts, aes(x = Sample, y = RatioDiffSal, colour = "RatioDiffSal")) +
  theme_bw() +
  scale_colour_manual(name = NULL, values = colours) +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(y = "minimap2 counts minus StringTie or Salmon counts\ndivided by minimap2 counts") +
  ylim(0, 1)
____________________________________________________________________________________________________________________________________________________________________________________
#R SCRIPT: SalmonDownstream_DTU_DS21.R
-------
#https://www.bioconductor.org/packages/release/workflows/vignettes/rnaseqDTU/inst/doc/rnaseqDTU.html
#https://bioconductor.org/packages/release/bioc/vignettes/DRIMSeq/inst/doc/DRIMSeq.pdf
#See also the QTL analysis workflow in DRIMSeq vignette
#install.packages("BiocManager")
#BiocManager::install(version = "3.20")
#library(BiocManager)
#BiocManager::install("DRIMSeq")
#BiocManager::install("DEXSeq")
#BiocManager::install("stageR")
#BiocManager::install("tximport")
#BiocManager::install("txdbmaker")
rm(list=ls())

library(DRIMSeq)
library(DEXSeq)
library(stageR)
library(tximport)
library(txdbmaker)
library(GenomicFeatures)
library(dplyr)
library(ggplot2)
library(splitstackshape)
#library(conflicted)

##NEED TO ADD ON REMOVAL OF NAS FROM RES

#Importing counts
setwd("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R")
samps <- read.csv("DS2_8_2021_samples.csv")

files <- file.path("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/SalmonOut/",samps$sample_id,"_salmonout/quant.sf", fsep = "")
names(files) <- samps$sample_id
files

txi <- tximport(files, type = "salmon", txOut = TRUE,
                countsFromAbundance = "scaledTPM")
cts <- txi$counts
cts <- cts[rowSums(cts) > 0,]

#Transcript-to-gene mapping
#Need .gtf file from ensembl: https://ftp.ensembl.org/pub/release-109/gtf/drosophila_melanogaster/
gtf <- "Z:/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.109.gtf"
txdb.filename <- "Z:/simons_lab1/Shared/nanopore_output/Genomes_and_Transcriptomes/Drosophila_melanogaster.BDGP6.32.109.sqlite"
txdb <- txdbmaker::makeTxDbFromGFF(gtf)
#saveDb(txdb, txdb.filename)
#Once made this can be quickly reloaded (not totally sure what the benefit of this is yet? Maybe save externally to R?):
#txdb <- loadDb(txdb.filename)
txdf <- AnnotationDbi::select(txdb, keys(txdb, "GENEID"), "TXNAME", "GENEID") #use select from AnnotationDbi NOT dplyr!
tab <- table(txdf$GENEID)
txdf$ntx <- tab[match(txdf$GENEID, names(tab))]



##-------Statistical analysis of differential transcript usage
##-------DRIMSeq
#Data frame
counts <- data.frame(gene_id = txdf$GENEID, feature_id = txdf$TXNAME)
cts <- as.data.frame(cts)
cts <- tibble::rownames_to_column(cts, "feature_id")
counts <- merge(counts, cts, by = "feature_id")

#DRIMSeq
d <- dmDSdata(counts = counts, samples = samps)
d

#Filtering
#For a transcript to be retained, we require that:
d <- dmFilter(d,
              min_samps_gene_expr = 5, #guides suggest doing this in ALL samples but say for large n, you can reduce
              min_gene_expr = 10, #both guides say 10
              min_samps_feature_expr = 2, #guides suggest smallest sample size (in our case 2)
              min_feature_expr = 10) #both guides say 10
d
#Downstream guide suggests (min_feature_prop = 0.1), DRIMSeq manual does not suggest it - may remove lowly expressed txs

#Only genes that have >1 isoform since we are looking at DTU
#To see how many of the remaining genes have N isoforms:
table(table(counts(d)$gene_id))

#To get DTU p values for GO ontology for additive model:
#Precision, proportion and DTU estimation
#Design matrix
#Check csv is ordered so 'Rich_Control' samples are above 'DR_Switch' for levelling purposes!
design_full <- model.matrix(~ diet + line, data = DRIMSeq::samples(d))

colnames(design_full)

#Following 3 functions estimate model parameters and test for DTU:
#Use add_uniform to add a small fractional count to zeros, (adding a uniform random variable between 0 and 0.1)
#Allows analysis to include genes/features where count is 0 - otherwise it would throw an optim error

#Estimate the precision, which is related to the dispersion in the Dirichlet Multinomial model
d <- dmPrecision(d, design = design_full, verbose = 1, add_uniform = TRUE)
#FROM 5.2.3 SECTION IN DRIMSEQ MANUAL CAN ALSO LOOK AT GENE EXPRESSION!
common_precision(d)
#Fit regression coefficients and perform null hypothesis testing on the coefficient of interest
d <- dmFit(d, design = design_full, verbose = 1, add_uniform = TRUE)
#Testing for DTU
#LOOK AT 5.2.5 IN DRIMSEQ MANUAL AND CHAT TO MIRRE ABOUT IT - can use the design here?
d <- dmTest(d, coef = c("dietDR_Switch", "line57", "line181", "line228", "line208", "line101", "line229", "line235", "line177", "lineM22", "line91", "line83"), verbose = 1) #want to do this by coefficient as opposed to the whole design
#Coef specifies columns to remove to get the null model
head(coefficients(d))
head(DRIMSeq::results(d))

#plotPrecision(d)
#plotPValues(d)
#plotPValues(d, level = "feature")

#Build results table. Generate a single p-value per gene, which tests whether there is any differential transcript
#usage within the gene, or a single p-value per transcript, which tests whether the proportions for this transcript
#changed within the gene
res <- DRIMSeq::results(d)
#res.txp <- DRIMSeq::results(d, level="feature")
write.csv(res, "DietplusLine_DTUgenes.csv")
    
    
    

#Analyse effect of diet for each line separately
#Need to turn them back into dataframes to filter them
dsamps <- as.data.frame(DRIMSeq::samples(d))
dcounts <- as.data.frame(DRIMSeq::counts(d))
cols <- as.factor(c("gene_id", "feature_id"))
#Make overall DTU file
overall_DTU <- setNames(data.frame(matrix(ncol = 6, nrow = 0)), c("line", "gene_id", "lr", "df", "pvalue", "adj_pvalue"))

#Loop DTU analysis for each line
lines <- unique(dsamps$line)
#i = 1
for(i in (1:length(lines)))
  {
  samps <- dplyr::filter(dsamps, line == lines[i])
  #Loop to fetch count data for each sample. Need to forget the missing factors
  samps$sample_id <- samps$sample_id[ , drop = TRUE]
  samps
  ids <- unique(samps$sample_id)
  ids <- factor(c(cols, ids))
  counts <- dcounts %>% dplyr::select(ids)
  #Remove rows with 0 reads as done for cts earlier
  counts <- counts[rowSums(counts[,-c(1,2)]) > 0,]
  
  d <- dmDSdata(counts = counts, samples = samps)
  DRIMSeq::samples(d)
  
  #Precision, proportion and DTU estimation
  #Design matrix
  #Check csv is ordered so 'Rich_Control' samples are above 'DR_Switch' for levelling purposes!
  design_full <- model.matrix(~ diet, data = DRIMSeq::samples(d))
  
  colnames(design_full)
  
  #Following 3 functions estimate model parameters and test for DTU:
  #Use add_uniform to add a small fractional count to zeros, (adding a uniform random variable between 0 and 0.1)
  #Allows analysis to include genes/features where count is 0 - otherwise it would throw an optim error
  
  #Estimate the precision, which is related to the dispersion in the Dirichlet Multinomial model
  d <- dmPrecision(d, design = design_full, verbose = 1, add_uniform = TRUE)
  #FROM 5.2.3 SECTION IN DRIMSEQ MANUAL CAN ALSO LOOK AT GENE EXPRESSION!
  common_precision(d)
  #Fit regression coefficients and perform null hypothesis testing on the coefficient of interest
  d <- dmFit(d, design = design_full, verbose = 1, add_uniform = TRUE)
  #Testing for DTU
  #LOOK AT 5.2.5 IN DRIMSEQ MANUAL AND CHAT TO MIRRE ABOUT IT - can use the design here?
  d <- dmTest(d, coef = "dietDR_Switch", verbose = 1) #want to do this by coefficient as opposed to the whole design
  #Coef specifies columns to remove to get the null model
  head(coefficients(d))
  head(DRIMSeq::results(d))
  
  #plotPrecision(d)
  #plotPValues(d)
  #plotPValues(d, level = "feature")
  
  #Build results table. Generate a single p-value per gene, which tests whether there is any differential transcript
  #usage within the gene, or a single p-value per transcript, which tests whether the proportions for this transcript
  #changed within the gene
  res <- DRIMSeq::results(d)
  #res.txp <- DRIMSeq::results(d, level="feature")
  write.csv(res, paste(lines[i], "_DTUgenes.csv"))
  
  #Plot estimated proportions for one of the significant genes where evidence of isoform switching
  idx <- which(res$adj_pvalue < 0.05)
  
  #To get plots out for the significant genes
  res[idx,]
  if (nrow(res[idx,]) > 0){ #not tested whether this skips the empty DF yet
  for(g in 1:length(idx))
  {
    #g = 1
    #Need to plot it first or it saves a blank png
    plot <- DRIMSeq::plotProportions(d, gene_id = res$gene_id[idx[g]], group_variable = "diet", plot_type = "boxplot1", order_features = FALSE)
    png(paste(lines[i], res$gene_id[idx[g]], "DS21_DTUplot.png", sep = "_"))
    print(plot)
    dev.off()
  }}
  #DTUgenes <- res[idx,]
  DTUgenes <- res
  DTUgenes$line = paste(lines[i])
  DTUgenes <- DTUgenes[,c(6, 1, 2, 3, 4, 5)]
  overall_DTU <- rbind(overall_DTU, DTUgenes)
}
overall_DTU
write.csv(overall_DTU, "DTUgenes.csv")

sig_overall_DTU <- overall_DTU %>% dplyr::filter(adj_pvalue < 0.06)
genecounts <- as.data.frame(table(sig_overall_DTU$gene_id))
#multiplegenes <- genecounts %>% dplyr::filter(Freq > 1)
write.csv(genecounts, "Counts_sigDTUgenes.csv")



#UP TO HERE FOR NOW
  
  

  #Turn p value NAs into 1s as they would cause issues for stage-wise analysis
  no.na <- function(x) ifelse(is.na(x), 1, x)
  res$pvalue <- no.na(res$pvalue)
  res.txp$pvalue <- no.na(res.txp$pvalue)
  
  
  
  
  
  
  
  ##-------stageR
  #stageR asks 1. which genes contain evidence of DTU? 2. which transcripts in those genes are participating in the DTU?
  #Two steps: screening and confirmation
  #Assign gene-level pvalues to the screening stage
  pScreen <- res$pvalue
  names(pScreen) <- res$gene_id
  #Assign tx-level pvalues to the confirmation stage
  pConfirmation <- matrix(res.txp$pvalue, ncol = 1)
  rownames(pConfirmation) <- res.txp$feature_id
  #Create gene-tx mapping
  tx2gene <- res.txp[, c("feature_id", "gene_id")]
  #Create the stageRTx object and perform stage-wise analysis
  stageR0bj <- stageRTx(pScreen = pScreen, pConfirmation = pConfirmation, pScreenAdjusted = FALSE, tx2gene = tx2gene)
  stageR0bj <- stageWiseAdjustment(object = stageR0bj, method = "dtu", alpha = 0.1)
  getSignificantGenes(stageR0bj)
  getSignificantTx(stageR0bj)
  drim.padj <- getAdjustedPValues(stageR0bj, order = TRUE, onlySignificantGenes = FALSE)
  head(drim.padj)
  #The final table with adjusted p-values summarizes the information from the two-stage analysis
  #Only genes that passed the filter are included in the table, so the table already represents screened genes
  #The transcripts with values in the column, transcript, less than 0.05 pass the confirmation stage on a target
  #5% overall false discovery rate, or OFDR. This means that, in expectation, no more than 5% of the genes that
  #pass screening will either (1) not contain any DTU, so be falsely screened genes, or (2) contain a falsely confirmed
  #transcript. A falsely confirmed transcript is a transcript with an adjusted p-value less than 0.05 which does not
  #exhibit differential usage across condition. The stageR procedure allows us to look at both the genes that passed the
  #screening stage and the transcripts with adjusted p-values less than our target alpha, and understand what kind of
  #overall error rate this procedure entails. This cannot be said for an arbitrary procedure of looking at standard gene
  #adjusted p-values and transcript adjusted p-values, where the adjustment was performed independently.
  drim.padj$line = paste(lines[i])
  drim.padj <- drim.padj[,c(5, 1, 2, 3, 4)]
  write.csv(drim.padj, paste(lines[i], "_drimpadj_DTU.csv", sep =""))
  overall_drim.padj <- rbind(overall_drim.padj, drim.padj)
}  
  
write.csv(overall_drim.padj, "AllLines_drimpadj_DTU.csv")



##-------Just plotting
#rm(list=ls())
setwd("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R")
allpadj <- read.csv('AllLines_drimpadj_DTU.csv')
sigg <- filter(allpadj, gene < 0.05)
sigg <- sigg[,c(2,3,4,5,6)]

unique(sigg$geneID)
unique(sigg$txID)

ALLsamps <- read.csv("DS2_8_2021_samples.csv")
lines <- unique(ALLsamps$line)
for(i in 1:length(lines))
{
  oneline <- filter(sigg, line == lines[i])
  oneline <- unique(as.character(oneline$geneID, sep = ""))
  assign(paste("genelist", lines[i], sep = ""), oneline)
}

#Edited code above to fetch DTU plots for each line for each gene



  
  



   
#BELOW NOT RUN FOR POSTER DATA
  
##-------Post-hoc filtering on the standard deviation in proportions
#DRIMSeq can exceed FDR bounds so post-hoc filtering of p vals improved FDR/OFDR control. Use SD for filtering
#P vals may no longer be uniform after filtering out small effect txs and genes, but probably makes it MORE conservative
res.txp.filt <- DRIMSeq::results(d, level = "feature")
smallProportionSD <- function(d, filter = 0.1) {
  cts <- as.matrix(subset(counts(d), select = -c(gene_id, feature_id)))
  gene.cts <- rowsum(cts, counts(d)$gene_id)
  total.cts <- gene.cts[match(counts(d)$gene_id, rownames(gene.cts)),]
  props <- cts/total.cts
  propSD <- sqrt(rowVars(props))
  propSD < filter
}
filt <- smallProportionSD(d)
res.txp.filt$pvalue[filt] <- 1 
res.txp.filt$adj_pvalue[filt] <- 1



##-------DEXSeq
#When it says 'exon', this means 'transcript' for our analysis
#DEXSeq will test – after accounting for total gene expression for this sample and for the proportion of this transcript
#relative to the others – whether there is a condition-specific difference in the transcript proportion relative to others
sample.data <- DRIMSeq::samples(d)
count.data <- round(as.matrix(counts(d)[,-c(1:2)]))
dxd <- DEXSeqDataSet(countData = count.data,
                     sampleData = sample.data,
                     design = ~sample + exon + diet:exon,
                     featureID = counts(d)$feature_id,
                     groupID = counts(d)$gene_id)
#DEXSeq analysis
system.time({
  dxd <- estimateSizeFactors(dxd)
  dxd <- estimateDispersions(dxd, quiet = TRUE)
  dxd <- testForDEU(dxd, reducedModel = ~sample + exon)
})
#Compute per-gene adjusted p val and construct results table
dxr <- DEXSeqResults(dxd, independentFiltering = FALSE)
qval <- perGeneQValue(dxr)
dxr.g <- data.frame(gene = names(qval), qval)
#Can also reduce tx-level results table to simple df
columns <- c("featureID", "groupID", "pvalue")
dxr <- as.data.frame(dxr[,columns])
head(dxr)



##-------stageR following DEXSeq
#Similar code to that used for stageR above
strp <- function(x) substr(x, 1, 15)
pConfirmation <- matrix(dxr$pvalue, ncol= 1)
dimnames(pConfirmation) <- list(strp(dxr$featureID), "transcript")
pScreen <- qval
names(pScreen) <- strp(names(pScreen))
tx2gene <- as.data.frame(dxr[,c("featureID", "groupID")])
for (i in 1:2) tx2gene[,i] <- strp(tx2gene[,i])
#Following three functions provide a table with the OFDR control described above
#Set of genes passing screening should not have more than (alpa)% of either genes which have in fact no DTU or genes
#which contain a transcript with an adjusted p-value less than (alpha)% which do not participate in DTU
stageRObj <- stageRTx(pScreen = pScreen, pConfirmation = pConfirmation,
                      pScreenAdjusted = TRUE, tx2gene = tx2gene)
stageRObj <- stageWiseAdjustment(stageRObj, method = "dtu", alpha = 0.1)
suppressWarnings({
  dex.padj <- getAdjustedPValues(stageRObj, order = FALSE,
                                 onlySignificantGenes = TRUE)
})
head(dex.padj)

#Stopped at section 6 as don't need DGE right now
____________________________________________________________________________________________________________________________________________________________________________________
#R SCRIPT: Ballgown_EdgeR_DE_Script_DietSwitch2021.R
-------
#Make sure you have the most up to date version of BiocManager etc
# install.packages('Rtools')
# install.packages('BiocManager')
# BiocManager::install(version = '3.18')
# library(BiocManager)
# BiocManager::install("ballgown")
# BiocManager::install("GO.db")
# BiocManager::install("org.Dm.eg.db")

rm(list=ls())

library(ballgown)
library(edgeR)
#library(stringr)
library(GO.db)
library(org.Dm.eg.db)
library(tidyverse)
library(corrplot)
#library(Hmisc)
library(anndata)
#https://www.datanovia.com/en/blog/venn-diagram-with-r-or-rstudio-a-million-ways/
# library(ggvenn)
# library(ggVennDiagram)
# library(plotly)
setwd("Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/DietSwitch2_8_2021_R")

##-------SETTING UP THE BALLGOWN OBJECT
#We have already run tablemaker to create the ctab files as specified in the vignette.
#Using the version mapped to the genome rather than our transcriptome as otherwise the gene names aren't correct.
#The quasi-likelihood method is highly recommended for differential expression analyses of bulk RNA-seq data as it gives stricter error rate control by
#accounting for the uncertainty in dispersion estimation. The likelihood ratio test can be useful in some special cases such as single cell RNA-seq and
#datasets with no replicates.

#Move the .bam files into a BamFiles folder.

#Read in treatments for sample names
pheno <- read.csv("DS2_8_2021_SampleNames_minus3.csv")
#To order the pheno file alphabetically like the sample names will be in the bg object:
pheno = pheno[order(pheno$samplename),]

#Create overall bg object
overallbg = ballgown(dataDir = 'Z:/simons_lab1/Shared/nanopore_output/DietSwitch2_8_2021/MinimapOut/', samplePattern='Sample*', meas='all')
overallbg

#Add line information
pData(overallbg) = data.frame(id = pheno$samplename, group.line = pheno$line, group.diet = pheno$diet)
pData(overallbg)







##-------Loop
#Set up the loop to run through steps for all samples
linesthere = unique(pheno$line)

for(i in 1:length(linesthere))
{
  currentline = linesthere[i]
  #currentline = linesthere[1]
  bg = subset(overallbg, "group.line == currentline", genomesubset = FALSE)
  ##Accessing assembly data:
  #structure specifies genomics locations and relationships between exons, introns and transcripts.
  #expr is a list that contains tables of expression data for the genomic features.
  #indexes connects the pieces of the assembly and provides other experimental info - pData holds pheno info and must be added manually.
  #dirs gives full paths to Tablemaker output.
  #mergedDate is when the ballgown object was created.
  #meas gives the expression measurements present in the object.
  #When performing analyses on bg object, don't use FPKM as not suitable for long-read data since reads are all different lengths unlike Illumina etc.
  
  samples = sampleNames(bg)
  exonexpr <- eexpr(bg)
  transcript_id_by_exon = indexes(bg)$e2t$t_id[match(unique(indexes(bg)$e2t$e_id), indexes(bg)$e2t$e_id)]
  transcript_id_by_gene = indexes(bg)$t2g$t_id #Transcript/gene mapping
  geneID = indexes(bg)$t2g$g_id[match(transcript_id_by_exon, transcript_id_by_gene)]
  exonID = row.names(exonexpr)
  
  #This can get gene expression:
  #gene_expression = gexpr(bg)
  #trans_expression = texpr(bg)
  #edgeR good for the models: the quasi-likelihood method is highly recommended for differential expression analyses of bulk RNA-seq data
  
  
  
  ##edgR:
  #Preparing file for edgR
  #Important to read in clean and not as a data frame
  gns = as.data.frame(cbind(as.character(geneID), bg@expr$exon$chr, bg@expr$exon$start, bg@expr$exon$end, bg@expr$exon$strand, (bg@expr$exon$end-bg@expr$exon$start), bg@expr$exon$e_id))
  names(gns) = c("GeneID", "Chr", "Start", "End", "Strand", "Length", "ExonID")
  smpl = as.vector(colnames(exonexpr))
  cnts = as.matrix(exonexpr)
  
  #Raw counts and sum per gene
  sumgene = aggregate(cnts~gns$GeneID,FUN=sum)
  cntsgene = data.matrix(sumgene[,-1])
  rownames(cntsgene) = sumgene[,1]
  colnames(cntsgene) = colnames(cnts)
  str(cntsgene)
  gnsgene = rownames(cntsgene)
  
  #Make DGEList - edgeR object that can be manipulated like a list in R - matrix of counts contains integer counts, data.frame samples contains info about samples,
  #data.frame genes contains annotation. data.frame samples also contains column group for treatments
  #Filter to remove genes that have no counts at all
  edg = DGEList(counts = cntsgene, samples = smpl, genes = gnsgene, remove.zeros = T)
  
  #Check distribution of counts across genes
  AllCounts <- getCounts(edg)
  AllCounts <- as.data.frame(AllCounts)
  AllCounts$SumCounts <- rowSums(AllCounts)
  #Divide by number of samples (fine for this as repeating lots, usually would divide by overall reads or something)
  AllCounts$SumCountsDiv = (AllCounts$SumCounts/6)
  
  hist(AllCounts$SumCountsDiv)
  hist(log(AllCounts$SumCountsDiv))
  hist(log(AllCounts$SumCountsDiv), breaks = 500)
  
  #Look at the histograms above to decide the cpm threshold to use (5-10cpm to be considered expressed in a library and have biological significance, though differs between approaches)
  #eg If there are >20 cpm for this read in at least 8 of the samples, keep the gene, would be:
  #keep <- rowSums(cpm(edg) >20) >=8
  # exp(3)
  keep <- rowSums(cpm(edg) >5) >=3 #keeps around half the genes
  summary(keep)
  #To filter the DGEList above:
  filteredg = edg[keep, , keep.lib.sizes = FALSE]
  #Need to normalise library sizes using TMM to create effective library sizes to correct for small proportions of highly expressed genes consuming a substantial
  #portion of the library size for a sample
  normedg = calcNormFactors(filteredg)
  
  
 
  
  
  
  
  #######TESTING FOR DE GENES#######
  #Obtain dispersion estimates and negative binomial GLMs to determine DE using quasi-likelihood (QL, best  as it reflects uncertainty in estimating dispersion) methods
  #Estimate dispersion using Cox-Reid (CR) profile-adjusted likelihood method for general experiments with multiple factors. It fits GLMs with a design matrix to overcome
  #issues of multiple factors
  #Need to generate a design matrix
  fordesignmatrix = read.csv('DS2_8_2021_SampleNames_minus3.csv')
  #To order the design matrix alphabetically:
  fordesignmatrix = fordesignmatrix[order(fordesignmatrix$samplename),]
  #Select relevant samples
  fordesignmatrix = filter(fordesignmatrix, samplename == samples)
  str(fordesignmatrix)
  fordesignmatrix$diet = factor(fordesignmatrix$diet)
  fordesignmatrix$diet = relevel(fordesignmatrix$diet, ref="8")
  
  design = model.matrix(~1+diet, data = fordesignmatrix)
  rownames(design) = fordesignmatrix$samplename
  design
  #To estimate common, trended and tagwise dispersions all at once:
  estdisp = estimateDisp(normedg, design)
  
  #Testing for DE genes
  #The coefficient is the column you are looking at from the model, see columns using:
  colnames(design)
  design
  #this would be old school way of fitting data, might be better with small sample sizes.
  fitglm <- glmFit(estdisp, design)
  lrtglm <- glmLRT(fitglm, coef = 2)
  #topTags(lrtglm, n = 20)
  
  #write.csv(lrtglm$table, paste("lrtglm_DGRP2_8_TopGenes_Line", currentline, "_edgeR.csv", sep = ''))
  
  
  
  
  
  ###GOT UP TO HERE!!!!!!! CHANGING NAMES ETC BUT NOT RUN UP TO HERE
  
  
  
  
  
  ##Splicing analysis
  #Uing glmQLfit for this. (Might work with classic way too as above, lrt model)
  sampleNames(bg)
  exonexpr <- eexpr(bg)
  transcript_id_by_exon = indexes(bg)$e2t$t_id[match(unique(indexes(bg)$e2t$e_id), indexes(bg)$e2t$e_id)]
  transcript_id_by_gene = indexes(bg)$t2g$t_id #Transcript/gene mapping
  geneID = indexes(bg)$t2g$g_id[match(transcript_id_by_exon, transcript_id_by_gene)]
  exonID = row.names(exonexpr)
  gns = as.data.frame(cbind(as.character(geneID), bg@expr$exon$chr, bg@expr$exon$start, bg@expr$exon$end, bg@expr$exon$strand, (bg@expr$exon$end-bg@expr$exon$start), bg@expr$exon$e_id))
  names(gns) = c("GeneID", "Chr", "Start", "End", "Strand", "Length", "ExonID")
  smpl = as.vector(colnames(exonexpr))
  #Need to read in as matrix for it to work
  cnts = as.matrix(exonexpr)
  edg = DGEList(counts = cnts, samples=smpl, genes = gns, remove.zeros = T)
  
  keep <- rowSums(cpm(edg) >5) >=6
  summary(keep)
  edg <- edg[keep, , keep.lib.sizes=FALSE]
  edg <- calcNormFactors(edg)
  edg$samples
  
  fordesignmatrix = read.csv('DGRP2_8_2021_SampleNames.csv')
  #Select relevant samples
  fordesignmatrix = filter(fordesignmatrix, samplename == samples)
  str(fordesignmatrix)
  fordesignmatrix$diet = factor(fordesignmatrix$diet)
  fordesignmatrix$diet = relevel(fordesignmatrix$diet, ref="8")
  
  design = model.matrix(~1+diet, data = fordesignmatrix)
  rownames(design) = fordesignmatrix$samplename
  design
  
  edg <- estimateDisp(edg, design, robust = TRUE) #Need to add disp to edg object
  #This uses normalised edg again, just in this part of the script it's not a separate object called normedg
  edg$common.dispersion
  
  fit3 <- glmFit(edg, design)
  colnames(design)
  fitsplice = diffSpliceDGE(fit3, coef=2,geneid=fit3$genes[,1], exonid=fit3$genes[,3])
  topSplice <- topSpliceDGE(fitsplice, number=20) #Simes test
  #To see exon-level testing for a gene
  
  
  #Gene annotation
  #To add Entrez Gene IDs - need to specify which package 'select' is coming from or it assumes Dplyr and gets an error
  ann <- AnnotationDbi::select(org.Dm.eg.db,keys = as.vector(topSplice$GeneID), columns = c("FLYBASE","ENTREZID","SYMBOL","GENENAME"), keytype="FLYBASE")
  #write.csv(cbind(ann,topSplice), paste("SPLICINGlrtglm_DGRP2_8_Top20Genes_Line", currentline, "_edgeR.csv", sep = ''))
}



##---------------------Saving csv to make correlation plots in merge script

geneID = indexes(overallbg)$t2g$g_id[match(transcript_id_by_exon, transcript_id_by_gene)]
geneID
#write.csv(geneID, "allFBgnsindataset.csv")







##---------------------Investigate exons expressed in different lines
#For each gene for each line, do the following:
#Choose number of relevant line to filter the overallbg
linesthere = unique(pheno$line)

for(i in 1:length(linesthere))
{
#i = 14 #Change this after you've saved the relevant pdf below
#Filter out line
currentline = linesthere[i]
bg = subset(overallbg, "group.line == currentline", genomesubset = FALSE)
samples = sampleNames(bg)
#Get splicing info out as you do in the loop
sampleNames(bg)
exonexpr <- eexpr(bg)
transcript_id_by_exon = indexes(bg)$e2t$t_id[match(unique(indexes(bg)$e2t$e_id), indexes(bg)$e2t$e_id)]
transcript_id_by_gene = indexes(bg)$t2g$t_id #Transcript/gene mapping
geneID = indexes(bg)$t2g$g_id[match(transcript_id_by_exon, transcript_id_by_gene)]
exonID = row.names(exonexpr)
gns = as.data.frame(cbind(as.character(geneID), bg@expr$exon$chr, bg@expr$exon$start, bg@expr$exon$end, bg@expr$exon$strand, (bg@expr$exon$end-bg@expr$exon$start), bg@expr$exon$e_id))
names(gns) = c("GeneID", "Chr", "Start", "End", "Strand", "Length", "ExonID")
smpl = as.vector(colnames(exonexpr))
#Need to read in as matrix for it to work
cnts = as.matrix(exonexpr)
edg = DGEList(counts = cnts, samples=smpl, genes = gns, remove.zeros = T)

keep <- rowSums(cpm(edg) >5) >=6
summary(keep)
edg <- edg[keep, , keep.lib.sizes=FALSE]
edg <- calcNormFactors(edg)
edg$samples

fordesignmatrix = read.csv('DGRP2_8_2021_SampleNames.csv')
#Select relevant samples
fordesignmatrix = filter(fordesignmatrix, samplename == samples)
str(fordesignmatrix)
fordesignmatrix$diet = factor(fordesignmatrix$diet)
fordesignmatrix$diet = relevel(fordesignmatrix$diet, ref="8")

design = model.matrix(~1+diet, data = fordesignmatrix)
rownames(design) = fordesignmatrix$samplename
design

edg <- estimateDisp(edg, design, robust = TRUE) #Need to add disp to edg object
#This uses normalised edg again, just in this part of the script it's not a separate object called normedg
edg$common.dispersion

fit3 <- glmFit(edg, design)
colnames(design)
fitsplice = diffSpliceDGE(fit3, coef=2,geneid=fit3$genes[,1], exonid=fit3$genes[,3])

#To look at the table of exons for a gene of interest:
#CHECKGENES <- filter(fitsplice$genes, GeneID == "FBgn123456789")

#Save the fitsplice info for each line
#write.csv(fitsplice$genes, paste(currentline, "_fitsplice_allgenes.csv", sep = ""))

#Write a new fitsplice file for each line to make a facet plot:
#assign(paste("fitsplice", currentline, sep = ""), fitsplice)

#Save png of Sarm FBgn0262579 for each line
png(paste("Sarm_plotSpliceDGE_DGRP", currentline, ".png", sep = ""))
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
dev.off()

#Assign fitsplice it's own name ready to use for the simulation below
assign(paste("fitsplice", currentline, sep = ""), fitsplice)
}



#SIMULATE HOW MANY GENES ARE EXPECTED TO SHARE ALTERNATIVE SPLICING BY CHANCE
#Total no. genes can then be used to predict the expected number of genes that are alternatively spliced in several lines by chance for our simulation.
#Merge the fitsplice for each line created above.
overallfitsplicegenes <- bind_rows(fitsplice101$gene.genes, fitsplice177$gene.genes, fitsplice181$gene.genes, fitsplice195$gene.genes, fitsplice208$gene.genes, fitsplice228$gene.genes, fitsplice229$gene.genes, fitsplice235$gene.genes, fitsplice256$gene.genes, fitsplice42$gene.genes, fitsplice57$gene.genes, fitsplice83$gene.genes, fitsplice91$gene.genes, fitspliceM22$gene.genes)
#Get number of unique genes out.
length(unique(overallfitsplicegenes$GeneID))
#5069 unique genes
#Previously figured out how many genes only have one exon so can't be alt spliced, but can't seem to see where this came from as in the fitsplice
#dataset, all genes have >1 exon because it's looking at splicing. Discount this for now and just simulate for 5069 genes.
genes = 1:5069
lines = 14
sims = 10000
top = 20

resultsim=matrix(nrow=top*lines,ncol=sims)

k=1
while(k<(sims+1)){
  
  results=matrix(lines*top)
  for (i in 1:lines){
    results[(1:top)+(i-1)*top]=sample(genes,size=top)
  }
  
  resul_form=data.frame(unclass(sort(table(results))))[,1]
  resultsim[((top*lines)-length(resul_form)+1):(top*lines),k]=resul_form
  
  k=k+1
}




#To pick out the genes that are the top appearances for AS across all lines, make an excel:
#SPLICINGlrtglm_DGRP2_8_Top20Genes_ALLLINES_edgeR
#Copy top 20 hits for splicing from each line into this excel and add column for line.
#Then, make new excel tab to count individual occurrences of each gene in the ALLLINES tab to ID top appearances across all lines and which lines they appear in.
#Use this to identify which genes to pull out exon profiles of for each line below:

#To plot the exons used for each gene for this line
#plotSpliceDGE(fitsplice, geneid = "FBgnxxx", genecolname = "GeneID")

#For 1 195 (i=1): FBgn0086687 FBgn0261244
#2 57: FBgn0086687 FBgn0027657 FBgn0051523 FBgn0052425
#3 181: FBgn0086687
#4 228: FBgn0051523
#5 208: FBgn0086687 FBgn0262579 FBgn0027657 FBgn0051523
#6 101: FBgn0262579
#7 256: FBgn0262579
#8 229: NA
#9 235: FBgn0027657 FBgn0261244
#10 177: FBgn0262579
#11 M22: FBgn0086687 FBgn0262579 FBgn0027657 FBgn0261244 FBgn0051523 FBgn0052425
#12 42: FBgn0086687 FBgn0052425
#13 91: FBgn0027657 FBgn0052425
#14 83: FBgn0262579 FBgn0052425

#Save them for each line
#1
pdf("195_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0261244", genecolname = "GeneID")
dev.off()

#2
pdf("57_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0027657", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0051523", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0052425", genecolname = "GeneID")
dev.off()

#3
pdf("181_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
dev.off()

#4 228
pdf("228_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0051523", genecolname = "GeneID")
dev.off()

#5
pdf("208_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0027657", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0051523", genecolname = "GeneID")
dev.off()

#6
pdf("101_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
dev.off()

#7
pdf("256_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
dev.off()

#None for #8 229

#9
pdf("235_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0027657", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0261244", genecolname = "GeneID")
dev.off()

#10
pdf("177_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
dev.off()

#11
pdf("M22_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0027657", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0261244", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0051523", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0052425", genecolname = "GeneID")
dev.off()

#12
pdf("42_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0086687", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0261244", genecolname = "GeneID")
dev.off()

#13
pdf("91_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0027657", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0052425", genecolname = "GeneID")
dev.off()

#14
pdf("83_TopGenes_Exons.pdf")
plotSpliceDGE(fitsplice, geneid = "FBgn0262579", genecolname = "GeneID")
plotSpliceDGE(fitsplice, geneid = "FBgn0052425", genecolname = "GeneID")
dev.off()
